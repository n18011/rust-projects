# データ型

Rustにおける値は全て、何らかのデータ型になる。


Rustは静的型付き言語である。  コンパイル時に全ての変数の型が判明している必要がある。


複数の型が推論される可能性がある場合、型注釈をつけなければならない。


```rust
fn main() {
let guess: u32 = "42".parse().expect("Not a number!");    // 数字ではありません！
}
```
`let guess: u32`の`u32`という型注釈がないと  このようになる
```rust
error[E0282]: type annotations needed
              (型注釈が必要です)
 --> src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("Not a number!");
  |         ^^^^^ cannot infer type for `_`
  |               (`_`の型が推論できません)
  |
  = note: type annotations or generic parameter binding required
    (注釈: 型注釈、またはジェネリクス引数束縛が必要です)
```


## スカラー型
スカラー型は、単独の値を表す。Rustには主に4つのスカラー型がある。


- [整数](#整数型)
- [浮動小数点数](#浮動小数点数型)
- [論理値](#論理値型)
- [文字](#文字型)


### 整数型

表: 整数型


|大きさ|符号付き|符号なし|
|:------|:-------:|:-------:|
|8-bit|`i8`|`u8`|
|16-bit|`i16`|`u16`|
|32-bit|`i32`|`u32`|
|64-bit|`i64`|`u64`|
|arch|`isize`|`usize`|


符号付きと符号なしは、 数値が正負を持つかどうかを示す。  数値が符号を持つ必要があるかどうか(符号付き)、または、 絶対に正数にしかならず符号なしで表現できるかどうか(符号なし)


各符号付きバリアントは、-(2n - 1)以上2n - 1 - 1以下の数値を保持できる(nはこのバリアントが使用するビット数)


よって、


`i8`型は-128から127までを保持できる。 `u8`型は0から255までを保持できる。


isizeとusize型は、プログラムが動作しているコンピュータの種類に依存する
- 64ビットアーキテクチャなら、64ビット
- 32ビットアーキテクチャなら、32ビット


表: 整数リテラル


|数値リテラル|例|
|:-----------|:-----------:|
|10|`98_222`|
|16|`0xff`|
|8|`0o77`|
|2|`0b1111_0000`|
|バイト(u8だけ)|`b'A'`|


- 整数型の基準はi32型
- isizeとusizeを使う主な状況は、何らかのコレクションにアクセスすること


### 浮動小数点数型
浮動小数点型は、`f32`と`f64`で、それぞれ32ビットと64ビットサイズ。基準型は`f64`。
```rust:src/main.rc
fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
```


#### 数値計算
```rust:src/main.rc
fn main() {
    // 足し算
    let sum = 5 + 10;

    // 引き算
    let difference = 95.5 - 4.3;

    // 掛け算
    let product = 4 * 30;

    // 割り算
    let quotient = 56.7 / 32.2;

    // 余り
    let remainder = 43 % 5;
}
```


### 論理値型
- `true`と`false`  値は二つしかない
- 論理値型は、boolと指定される。


```rust:src/main.rc
fn main() {
    let t = true;

    let f: bool = false; // 明示的型注釈付きで
}
```


### 文字型
`char`は、ダブルクォーテーションマークを使用する文字列に対して、シングルクォートで指定される
```rust:src/main.rc
fn main() {
   let c = 'z';
   let z = 'ℤ';
   let heart_eyed_cat = '😻';    //ハート目の猫
}
```


Rustのchar型は、ユニコードのスカラー値を表す。
- アクセント文字
- 中国語、日本語、韓国語文字
- 絵文字
- ゼロ幅スペース


## 複合型
複合型により、複数の値を一つの型にまとめることができる。


- [タプル](#タプル型)
- [配列](#配列型)


### タプル型
複数の型の何らかの値を一つの複合型にまとめ上げる。タプルの位置ごとに型があり、 タプル内の値はそれぞれ全てが同じ型である必要はない。
```rust:src/main.rc
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
```


タプルから個々の値を取り出すには、パターンマッチングを使用して分解することができる。
```rust:src/main.rc
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {}", y);
}
```


パターンマッチングを通しての分配の他にも、アクセスしたい値の番号をピリオド(.)に続けて書くことで、 タプルの要素に直接アクセスすることもできる。
```rust:src/main.rc
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
```
他の言語同様、最初のインデックスは0



### 配列型
タプルと異なり、配列の全要素は、 同じ型でなければならない。

Rustの配列は固定長なため、一度宣言されたら、サイズを伸ばすことも縮めることもできない

```rust:src/main.rc
fn main() {
    let a = [1, 2, 3, 4, 5];
}
```


- 配列は、ヒープよりもスタック(スタックとヒープについては第4章で詳つまびらかに議論します)にデータのメモリを確保したい時、 または、常に固定長の要素があることを確認したい時に有効
- 配列は、ベクタ型ほど柔軟ではない。  ベクタは、標準ライブラリによって提供されている配列と似たようなコレクション型で、サイズを伸縮させることができる。
- どちらを使うべきか確信が持てない時は、 おそらくベクタ型を使うべき


ベクタ型よりも配列を使いたくなるかもしれない例は、1年の月の名前を扱うプログラム  追加したり削除したりすることはまずない。要素の個数も固定なため。
```rust:src/main.rc
fn main() {
let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
}
```


#### 配列の要素にアクセスする
配列は、スタック上に確保される一塊のメモリ
```rust:src/main.rc
fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
```

#### 配列要素への無効なアクセス

```rust:src/main.rc
fn main() {
    let a = [1, 2, 3, 4, 5];
    let index = 10;

    let element = a[index];

    println!("The value of element is: {}", element);   // 要素の値は{}です
}
```
このようになる
```
$ cargo run
   Compiling arrays v0.1.0 (file:///projects/arrays)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/arrays`
thread '<main>' panicked at 'index out of bounds: the len is 5 but the index is
 10', src/main.rs:6
スレッド'<main>'は'範囲外アクセス: 長さは5ですが、添え字は10でした', src/main.rs:6
でパニックしました
note: Run with `RUST_BACKTRACE=1` for a backtrace.
```
コンパイルでは何もエラーが出なかったものの、プログラムは実行時エラーに陥り、 正常終了しません


要素に添え字アクセスを試みると、指定されたその添え字が配列長よりも小さいかを確認してくれる。添え字が配列長よりも大きければ、言語はパニックする。  パニックとは、プログラムがエラーで終了したことを表す


低レベル言語の多くでは、 この種のチェックは行われないため、間違った添え字を与えると、無効なメモリにアクセスできてしまう。
Rustでは、メモリアクセスを許可し、処理を継続する代わりに即座にプログラムを終了することで、 この種のエラーからプログラマを保護している。
