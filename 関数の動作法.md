# 関数
Rustの関数と変数の命名規則は、スネークケース  スネークケースとは、全文字を小文字にし、単語区切りにアンダースコアを使うこと

```rust:src/main.rs
fn main() {
    println!("Hello, world!");

    another_function();
}

fn another_function() {
    println!("Another function.");  // 別の関数
}
```
関数定義は、fnキーワードで始まり、関数名の後に丸かっこの組が続く。波かっこが、コンパイラに関数本体の開始と終了の位置を伝える。


定義した関数は、名前に丸かっこの組を続けることで呼び出すことができる。


```rust:src/main.rs
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.28 secs
     Running `target/debug/functions`
Hello, world!
Another function.
```
行出力は、main関数内に書かれた順序で実行されている。


## 関数の引数
```rust:src/main.rs
fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!("The value of x is: {}", x);   // xの値は{}です
}
```
```rust:src/main.rs
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 1.21 secs
     Running `target/debug/functions`
The value of x is: 5
```
関数シグニチャにおいて、各仮引数の型を宣言しなければならない。   関数定義で型注釈が必要不可欠ということは、コンパイラがその意図するところを推し量るのに、 プログラマがコードの他の箇所で使用する必要がないということを意味する。


関数に複数の仮引数を持たせたいときは、仮引数定義をカンマで区切る。
```rust:src/main.rs
fn main() {
    another_function(5, 6);
}

fn another_function(x: i32, y: i32) {
    println!("The value of x is: {}", x);
    println!("The value of y is: {}", y);
}
```
関数引数は、全てが同じ型である必要はない。
```rust:src/main.rs
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/functions`
The value of x is: 5
The value of y is: 6
```
`x`に対して値`5`、`y`に対して値`6`を渡して関数を呼び出した


### 関数本体は文と式を含む
関数本体は、文が並び、最後に式を置くか文を置くという形で形成される。  Rustは、式指向言語。

- 文とは、なんらかの動作をして値を返さない命令
- 式は結果値に評価


`let`キーワードを使用して変数を生成し、値を代入することは文になる。
```rust:src/main.rs
fn main() {
    let y = 6;
}
```
関数定義も文になる。つまり、先の例は全体としても文になる


文は値を返さない。そのため、`let`文を他の変数に代入することはできない。
```rust:src/main.rs
fn main() {
    let x = (let y = 6);
}
```
これはエラー
```rust:src/main.rs
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error: expected expression, found statement (`let`)
(エラー: 式を予期しましたが、文が見つかりました (`let`))
 --> src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^
  |
  = note: variable declaration using `let` is a statement
    (注釈: `let`を使う変数宣言は、文です)
```
このlet y = 6という文は値を返さないので、xに束縛するものがない


`5+6`は値`11`に評価される式。式は文の一部になりえる。`let y = 6`という文の`6`は値`6`に評価される式。関数呼び出しも式。マクロ呼び出しも式。新しいスコープを作る際に使用するブロック(`{}`)も式
```rust:src/main.rs
fn main() {
    let x = 5;

    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {}", y);
}
```
```rust:src/main.rs
{
    let x = 3;
    x + 1
}
```
は`4`に評価されるブロック。その後、`let`文の一部として`y`に束縛される。  式は終端にセミコロンを含まない。式の終端にセミコロンを付けたら、文に変えてしまう。そして、文は値を返さないので注意が必要。



## 戻り値のある関数
関数は、それを呼び出したコードに値を返すことができる。  `->`の後に型を書いて宣言する。


関数の戻り値は、関数本体ブロックの最後の式の値と同義。  `return`キーワードで関数から早期リターンし、値を指定することもできるが、多くの関数は最後の式を暗黙的に返す。
```rust:src/main.rs
fn five() -> i32 {
    5
}

fn main() {
    let x = five();

    println!("The value of x is: {}", x);
}
```
```rust:src/main.rs
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30 secs
     Running `target/debug/functions`
The value of x is: 5
```
five内の5が関数の戻り値。そのため、戻り値型がi32。


let x = five()という行は以下のように書くのと同義
```rust:src/main.rs
fn main() {
let x = 5;
}
```
関数本体はセミコロンなしの5単独。  これが返したい値になる式だから


別の例
```rust:src/main.rs
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: i32) -> i32 {
    x + 1
}
```
コードを走らせると、The value of x is: 6と出力される


x + 1を含む行の終端にセミコロンを付けて、式から文に変えたら、エラーになる
```rust:src/main.rs
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: i32) -> i32 {
    x + 1;
}
```
```rust:src/main.rs
error[E0308]: mismatched types
              (型が合いません)
 --> src/main.rs:7:28
  |
7 |   fn plus_one(x: i32) -> i32 {
  |  ____________________________^
8 | |     x + 1;
  | |          - help: consider removing this semicolon
9 | | }
  | |_^ expected i32, found ()
  |     (i32を予期したのに、()型が見つかりました)
  |
  = note: expected type `i32`
             found type `()`
```
 関数plus_oneの定義では、i32型を返すと言っているのに、文は値に評価されないから
