# 関数
Rustの関数と変数の命名規則は、スネークケース  スネークケースとは、全文字を小文字にし、単語区切りにアンダースコアを使うこと

```rust:src/main.rs
fn main() {
    println!("Hello, world!");

    another_function();
}

fn another_function() {
    println!("Another function.");  // 別の関数
}
```
関数定義は、fnキーワードで始まり、関数名の後に丸かっこの組が続く。波かっこが、コンパイラに関数本体の開始と終了の位置を伝える。


定義した関数は、名前に丸かっこの組を続けることで呼び出すことができる。


```rust:src/main.rs
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.28 secs
     Running `target/debug/functions`
Hello, world!
Another function.
```
行出力は、main関数内に書かれた順序で実行されている。


## 関数の引数
```rust:src/main.rs
fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!("The value of x is: {}", x);   // xの値は{}です
}
```
```rust:src/main.rs
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 1.21 secs
     Running `target/debug/functions`
The value of x is: 5
```
関数シグニチャにおいて、各仮引数の型を宣言しなければならない。   関数定義で型注釈が必要不可欠ということは、コンパイラがその意図するところを推し量るのに、 プログラマがコードの他の箇所で使用する必要がないということを意味する。


関数に複数の仮引数を持たせたいときは、仮引数定義をカンマで区切る。
```rust:src/main.rs
fn main() {
    another_function(5, 6);
}

fn another_function(x: i32, y: i32) {
    println!("The value of x is: {}", x);
    println!("The value of y is: {}", y);
}
```
関数引数は、全てが同じ型である必要はない。
```rust:src/main.rs
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/functions`
The value of x is: 5
The value of y is: 6
```
`x`に対して値`5`、`y`に対して値`6`を渡して関数を呼び出した


### 関数本体は文と式を含む
関数本体は、文が並び、最後に式を置くか文を置くという形で形成される。  Rustは、式指向言語。

- 文とは、なんらかの動作をして値を返さない命令
- 式は結果値に評価


`let`キーワードを使用して変数を生成し、値を代入することは文になる。
```rust:src/main.rs
fn main() {
    let y = 6;
}
```
関数定義も文になる。つまり、先の例は全体としても文になる


文は値を返さない。そのため、`let`文を他の変数に代入することはできない。
```rust:src/main.rs
fn main() {
    let x = (let y = 6);
}
```
これはエラー
```rust:src/main.rs
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error: expected expression, found statement (`let`)
(エラー: 式を予期しましたが、文が見つかりました (`let`))
 --> src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^
  |
  = note: variable declaration using `let` is a statement
    (注釈: `let`を使う変数宣言は、文です)
```
このlet y = 6という文は値を返さないので、xに束縛するものがない


`5+6`は値`11`に評価される式。式は文の一部になりえる。`let y = 6`という文の`6`は値`6`に評価される式。関数呼び出しも式。マクロ呼び出しも式。新しいスコープを作る際に使用するブロック(`{}`)も式
```rust:src/main.rs
fn main() {
    let x = 5;

    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {}", y);
}
```
```rust:src/main.rs
{
    let x = 3;
    x + 1
}
```
は`4`に評価されるブロック。その後、`let`文の一部として`y`に束縛される。  式は終端にセミコロンを含まない。式の終端にセミコロンを付けたら、文に変えてしまう。そして、文は値を返さないので注意が必要。
## 戻り値のある関数
```rust:src/main.rs
```
